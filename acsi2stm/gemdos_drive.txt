SD card mount / protocol switch:

Use cases for STRICT mode users that is autodetected:

* Boot from any SD card, before or after a non-bootable SD
* Format and prep a blank SD card with legacy tools on floppy / other hard drive
* SD card hotplug with proper media change support

Use cases for STRICT mode users that require setting the jumper:

* Format and prep a FAT32/EXFAT SD card with legacy tools on floppy / other hard drive
* Use "dual format" FAT32/TOS drivers booted from floppy

Use cases for GEMDOS users:

* Format a SD card from setup (standard FAT32/ExFAT format)
* Clear a SD card from setup (zero MBR and GPT)
* Create a disk image on the SD card
* SD card hotplug with proper media change support
* Boot with no SD card and have working SD card hotplug
* Format and prep a blank SD card on 2nd SD slot with tools on the 1st SD card
* Use it with another hard drive that uses a legacy driver.
  The legacy driver must not see the fake GEMDOS drive unless it is very poorly written.


On Atari reset:

* If strict mode switch is enabled: enter STRICT mode
* Scan all SD cards
* If one or more Atari bootable SD is present: enter STRICT mode
* If one or more SD card is present, but no card is mountable: enter STRICT mode
* Enter GEMDOS mode


STRICT mode:
* Exposes all SD cards as hard drives until next reset
* UltraSATAN RTC is enabled unless compiled-out
* Compile flag to select between removable (media change + device always present) / non-removable (no media change + device dead if no SD) logic


GEMDOS mode:
* Uses only the 1st ACSI ID on the bus, independently from present SD cards
* The 1st ACSI ID only reacts to the boot command to inject payload and one-byte commands
* Extra ACSI IDs react as non-removable block devices if not mounted
* Extra ACSI IDs don't react at all if no SD is present or if mounted








    if(!strict && !dev && card.slot == 0
     && cmdBuf[0] == 0x08
     && cmdBuf[1] == 0x00
     && cmdBuf[2] == 0x00
     && cmdBuf[3] == 0x00
     && cmdBuf[4] == 0x01
     && cmdBuf[5] == 0x00
    ) {
      // Boot sector query: inject the dummy payload
      commandStatus(processDummyBootSector());
      return;
    }



    if(memcmp(&cmdBuf[1], "USCurntFW", 9) == 0) {
      verbose("UltraSatan:");
      verbose("firmware query\n");
      // Fake the firmware
      DmaPort::sendDma((const uint8_t *)("ACSI2STM " ACSI2STM_VERSION "\r\n"), 16);
      commandStatus(ERR_OK);
      return;
    }
    if(memcmp(&cmdBuf[1], "USRdClRTC", 9) == 0) {
      verbose("UltraSatan:");
      verbose("clock read\n");
      tm_t now;
      rtc.getTime(now);

      buf[0] = 'R';
      buf[1] = 'T';
      buf[2] = 'C';
      buf[3] = now.year - 30;
      buf[4] = now.month;
      buf[5] = now.day;
      buf[6] = now.hour;
      buf[7] = now.minute;
      buf[8] = now.second;

      DmaPort::sendDma(buf, 16);
      commandStatus(ERR_OK);
      return;
    }
    if(memcmp(&cmdBuf[1], "USWrClRTC", 9) == 0) {
      verbose("UltraSatan:");
      verbose("clock set\n");

      DmaPort::readDma(buf, 9);

      if(buf[0] != 'R' || buf[1] != 'T' || buf[2] != 'C') {
        verbose("Invalid date\n");
        commandStatus(ERR_INVARG);
        return;
      }

      tm_t now;
      now.year = buf[3] + 30;
      now.month = buf[4];
      now.day = buf[5];
      now.hour = buf[6];
      now.minute = buf[7];
      now.second = buf[8];

      rtc.setTime(now);
      commandStatus(ERR_OK);
      return;
    }
#endif
    if(memcmp(&cmdBuf[1], "A2STFmtSd", 9) == 0) {
#if ACSI_READONLY
#if ACSI_READONLY == 2
      if(strict)
        commandStatus(ERR_WRITEPROT);
      else
        commandStatus(ERR_OK);
#else
      commandStatus(ERR_WRITEPROT);
#endif
#else
      if(!card.writable) {
        commandStatus(ERR_WRITEPROT);
        return;
      }

      verbose("ACSI2STM format SD\n");
      ExFatFormatter exFatFormatter;
      FatFormatter fatFormatter;
      verbose("Format started\n");

      // Start formatting
      // Return now so the ST can poll with inquiry
      commandStatus(ERR_OK);

      card.blocks > 67108864 ?
        exFatFormatter.format(&card.card, buf):
        fatFormatter.format(&card.card, buf);

      verbose("Format finished\n");
      mediaId = 0;

      mountDev(); // Remount in case we were accessing an image
#endif
      return;
    }
    if(memcmp(&cmdBuf[1], "A2STCIm", 7) == 0) {
#if ACSI_READONLY
#if ACSI_READONLY == 2
      if(strict)
        commandStatus(ERR_WRITEPROT);
      else
        commandStatus(ERR_OK);
#else
      commandStatus(ERR_WRITEPROT);
#endif
#else
      if(!card.writable) {
        commandStatus(ERR_WRITEPROT);
        return;
      }

      verbose("ACSI2STM create image\n");

      if(!card.fsOpen) {
        verbose("No filesystem\n");
        commandStatus(ERR_WRITEERR);
        return;
      }

      auto &fs = card.fs;
      FsFile dir = fs.open(ACSI_IMAGE_FOLDER);
      if(!dir.isDirectory()) {
        if(!dir) {
          fs.mkdir(ACSI_IMAGE_FOLDER);
          dir = fs.open(ACSI_IMAGE_FOLDER);
          if(!dir) {
            verbose("Cannot create directory\n");
            commandStatus(ERR_WRITEERR);
            return;
          }
        } else {
          verbose(ACSI_IMAGE_FOLDER " is not a directory\n");
          commandStatus(ERR_WRITEERR);
          return;
        }
      }

      if(fs.exists(ACSI_IMAGE_FOLDER "/" ACSI_IMAGE_FILE))
        fs.remove(ACSI_IMAGE_FOLDER "/" ACSI_IMAGE_FILE);

      // Read image size in multiples of 64k
      uint32_t imgSize = (uint32_t)cmdBuf[8] << 24 | (uint32_t)cmdBuf[9] << 16;

      if(!imgSize) {
        // If size is 0, delete the file
        commandStatus(ERR_OK);
        return;
      }

      FsFile f = fs.open(ACSI_IMAGE_FOLDER "/" ACSI_IMAGE_FILE, O_CREAT|O_RDWR);
      if(!f) {
        verbose("Cannot create image\n");
        commandStatus(ERR_WRITEERR);
        return;
      }

      // Image created.
      // Return now so the ST can poll with inquiry
      commandStatus(ERR_OK);

      uint32_t fsize = (uint32_t)f.fileSize();
      f.seekEnd();
      bzero(buf, bufSize);
      while(fsize < imgSize - bufSize) {
        if(f.write(buf, bufSize)) {
          fsize += bufSize;
        } else {
          verbose("Cannot write image\n");
          return;
        }
      }
      if(fsize < imgSize) {
        if(!f.write(buf, imgSize - fsize)) {
          verbose("Cannot write image\n");
          return;
        }
      }

      f.close();

      mediaId = 0;
#endif
      return;
    }
    if(memcmp(&cmdBuf[1], "A2STCmdTs", 9) == 0) {
      verbose("ACSI2STM command test\n");
      commandStatus(ERR_OK);
      return;
    }
    if(memcmp(&cmdBuf[1], "\0\0\0\0\0\0\0\0\0", 9) == 0) {
      verbose("ACSI2STM zero command test\n");
      commandStatus(ERR_OK);
      return;
    }
    if(memcmp(&cmdBuf[1], "\xff\xff\xff\xff\xff\xff\xff\xff\xff", 9) == 0) {
      verbose("ACSI2STM 0xff command test\n");
      commandStatus(ERR_OK);
      return;
    }


















          // Check that the write pattern matches
          bool error = false;
          for(int i = 0; i < 512; i += 4) {
            if(buf[offset + i] != 0xf0 || buf[offset + i + 1] != 0x0f || buf[offset + i + 2] != 0x55 || buf[offset + i + 3] != 0xaa) {
              verbose("Error at ", i, '\n');
              verboseDumpln(&buf[i],4);
              error = true;
            }
          }
